## Notes on chapter 15: Stream processing and incremental I/O

As mentioned in the text, an I/O monad is a kind of lowest common denominator for embedding externally-interpreted effects in a pure language--the model when programming _within_ `IO` is much the same as ordinary imperative programming. Hence, ever since the `IO` monad was first introduced in the early 1990s, functional programmers have been interested in finding more compositional ways of assembling programs that talk to the external world.

For a while, lazy I/O was still quite commonly used, despite its problems. Oleg Kiselyov, a prominent Haskell programmer and researcher, was very vocal in [pointing out the problems with lazy I/O](http://okmij.org/ftp/Haskell/Iteratee/Lazy-vs-correct.txt), and popularized the concept of _iteratees_, which is an early "ancestor" of the library we developed in this chapter. For more background, see [Oleg's page on stream processing](http://okmij.org/ftp/Streams.html). For a gentler exposition to iteratees, also see "Iteratee: Teaching an old fold new tricks" in [Issue 16 of The Monad Reader](http://themonadreader.files.wordpress.com/2010/05/issue16.pdf). [Oleg's site](http://okmij.org/ftp/) is a treasure trove of resources covering various aspects of FP, we highly recommend spending some time there.

In the past 5 years or so, there have been a number of variations developed on the basic idea of iteratees, generally aimed at making simpler to use and/or more expressive libraries. In Haskell, see the [conduit](https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview) and [pipes](https://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Tutorial.html) packages, as well as Edward Kmett's [machines](https://hackage.haskell.org/package/machines) package, which is the Haskell library which most closely related to the one in this chapter. 

There's been some pushback in the Haskell community that the conduit and pipes packages are overly complicated, and this has led to the development of the [io-streams](http://hackage.haskell.org/package/io-streams-1.0.1.0/docs/System-IO-Streams-Tutorial.html) package. The library is simpler in the sense that it is specialized to `IO` and bakes certain features directly into the basic stream types used, but in our opinion, this library isn't really a full replacement for a library like conduit, pipes, or machines. An important goal of a stream processing library is to allow for pure stream processing logic (often a majority of processing logic) to be defined separately from any I/O. Although having a more convenient abstraction for I/O streams is useful, more general purpose, abstract libraries are still important.

In the Scala world, the [scalaz-stream library](https://github.com/scalaz/scalaz-stream) developed out of work on [machines](https://hackage.haskell.org/package/machines) and the library developed here. Prior to that, there were ports of iteratees in the core [scalaz library](https://github.com/scalaz/scalaz).

### Functional reactive programming ###

Streaming processing and incremental I/O might not seem to have much to do with UI programming, but the problems have similarities. [Functional Reactive Programming](http://en.wikipedia.org/wiki/Functional_reactive_programming) (FRP) originated in the 1990s with work done by [Conal Elliott](http://conal.net/), Paul Hudak, and others (see Elliott's [list of publications](http://conal.net/papers/) and the 1997 paper [Functional Reactive Animation](http://conal.net/papers/icfp97/) by Elliott and Hudak). FRP is often put forward as a solution to the problem of describing interactive UIs in a functional way.

The FRP research has developed somewhat in parallel to the various approaches to streaming I/O mentioned above. According to Elliott, [what uniquely identifies FRP is the use of _continuous time_](http://conal.net/blog/posts/why-program-with-continuous-time), and on providing a simple, precise _denotation_ for the data types and various combinators. An FRP library is based around two types of signals:

* `Behavior[A]`: a time-varying `A` value, having a denotation `Time => A`.
* `Event[A]`: a discrete, time-varying sequence of `A` values, having a denotation of `List (Time, A)`.

These types (and their denotations) are deliberately abstract, which means that implementations are free to expose different sets of primitive combinators, and implementations are free to use very different implementation strategies, depending on what primitives are exposed to users. See [the chapter notes for chapter 9](Chapter-9:-Parser-combinators) for more about this style of design. For instance, the algebra might include the following functions:

* `def foldP[B,A](e: Event[A], z: B)(f: (B,A) => B): Event[B]` for left-folding the sequence of values represented by an `Event`.
* `def sample[A,B](e: Event[A], b: Behavior[B]): Event[B]` for sampling from a continuous behavior whenever an `Event` emits a value

Each of these operations can be given a clear interpretation in terms of the denotations of `Event` and `Behavior`, but implementations may use some more interesting representation of these types to facilitate efficient interpretation.

The FRP use of continuous time is important for much the same reasons that non-strictness is important. We saw in chapter 5 how non-strictness let us write more modular code, by decoupling the description of a computation (which may be infinite) from its evaluation. In the same way, continuous time lets us decouple the description of a time-varying program from any _sampling_ or _discretization_ that occurs at the end of the day when running our program.

In some ways, the denotations for `Event` and `Behavior` are a little _too_ flexible--there is no enforcement of _causality_, for instance--a `Behavior[A] => Behavior[B]` could in priciple let the value of the output behavior at time _t_ depend on the value of the input behavior at time _t + k_, essentially "looking into the future" to determine the value at the present. Elliott [discusses some of these problems in this post](http://conal.net/blog/posts/garbage-collecting-the-semantics-of-frp). The flexibility of the semantic model also means it is not immediately clear what actual algebra should be exposed to the programmer--we clearly want something expressive, but also limited "in the right ways" such that it is possible to implement efficiently. This is a challenging design problem in and of itself.

FRP is a deep area within functional programming. Here are just a few links to learn more:

* [Push-pull FRP](http://conal.net/papers/push-pull-frp/) by Elliott provides a nice, modern introduction to the ideas of FRP and discusses issues in crafting an efficient implementation. We also like [Heinrich Apfelmus' blog](http://apfelmus.nfshost.com/blog.html), which has a number of posts talking about FRP and various implementation issues.
* _Arrowized FRP (AFRP)_ arose in part because of the difficulties in formulating efficient implementations of the FRP model. In AFRP, behaviors and events are not first class, instead we have first-class signal transformers, generally based on some variation of the `Arrow` algebra. See [The Reactive Arcade](http://www.antonycourtney.com/pubs/hw03.pdf), which has an introduction to Yampa, an AFRP system, and also [Causal Commutative Arrows and their Optimization](http://cs-www.cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf), which discusses ways of optimizing AFRP for efficient implementation.
* With both arrowized and traditional FRP, there are questions about the best way to allow for various forms of context-sensitivity and dynamic switching between signals (sometimes called "dynamic event switching"). The need for this can arise in many situations, but, for instance, it can be used for modeling UIs in which the user can add and remove new UI elements by interacting with existing UI elements on the page. In traditional FRP, use of dynamic event switching can make it easy to introduce _time leaks_, due to accidentally retaining the full history of an `Event`--Heinrich Apfelmus [discusses this issue here](http://apfelmus.nfshost.com/blog/2011/05/15-frp-dynamic-event-switching.html). And in AFRP, since the signals themselves are not first class, it isn't immediately obvious what the best way is to represent and interact with a dynamic, changing set of signals (though this issue has been also addressed in the AFRP line of research, see [Antony Courtney's thesis](http://www.antonycourtney.com/pubs/ac-thesis.pdf) pg 123, also the [Reactive Arcade](http://www.antonycourtney.com/pubs/hw03.pdf) and [FRP, continued](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/workshop-02.pdf) papers).

Over time, the term "FRP" has been somewhat diluted, and the term is sometimes incorrectly used to refer to systems with discrete time, and even decidedly non-functional libraries making use of explicit callbacks and side effects!
